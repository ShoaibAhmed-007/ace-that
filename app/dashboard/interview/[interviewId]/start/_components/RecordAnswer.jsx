// "use client";

// import React, { useEffect, useState, useCallback } from "react";
// import Webcam from "react-webcam";
// import Image from "next/image";
// import { Button } from "../../../../../../components/ui/button";
// import useSpeechToText from "react-hook-speech-to-text";
// import { Mic, StopCircle } from "lucide-react";
// import { toast } from "sonner";
// import { db } from "../../../../../../utils/db";
// import { UserAnswer } from "../../../../../../utils/schema";
// import { useUser } from "@clerk/nextjs";
// import moment from "moment";

// function RecordAnswer({ mockInterviewQues, activeQuest, interviewData }) {
//   // User's answer (generated by speech recognition)
//   const [userAnswer, setUserAnswer] = useState("");
//   // Loading state while saving to db
//   const [loading, setLoading] = useState(false);
//   // Currently selected language for speech recognition
//   const [selectedLanguage, setSelectedLanguage] = useState("en-US");

//   // Currently authenticated user
//   const { user } = useUser();

//   // Supported languages for picker
//   const supportedLanguages = [
//     { code: "en-US", label: "English (US)" },
//     { code: "en-GB", label: "English (UK)" },
//     { code: "ur-PK", label: "Urdu (PK)" },
//     { code: "fr-FR", label: "French (FR)" },
//     { code: "zh-CN", label: "Chinese (Simplified)" },
//     { code: "zh-TW", label: "Chinese (Traditional)" },
//     { code: "hi-IN", label: "Hindi (IN)" },
//     { code: "es-ES", label: "Spanish (ES)" },
//     { code: "ar-SA", label: "Arabic (SA)" },
//     { code: "de-DE", label: "German (DE)" },
//     { code: "ja-JP", label: "Japanese (JP)" },
//     { code: "it-IT", label: "Italian (IT)" },
//     { code: "pt-PT", label: "Portuguese (PT)" },
//     { code: "pt-BR", label: "Portuguese (BR)" },
//     { code: "ru-RU", label: "Russian (RU)" },
//     { code: "ko-KR", label: "Korean (KR)" },
//     { code: "tr-TR", label: "Turkish (TR)" },
//   ];

//   // Speech recognition configuration
//   const {
//     error,
//     interimResult,
//     isRecording,
//     results,
//     startSpeechToText,
//     stopSpeechToText,
//     setResults,
//   } = useSpeechToText({
//     continuous: true,
//     useLegacyResults: false,
//     speechRecognitionLang: selectedLanguage,
//   });

//   // Combine recognized text
//   useEffect(() => {
//     if (results.length > 0) {
//       setUserAnswer(
//         (prevAns) => prevAns + results[results.length - 1].transcript + " "
//       );
//     }
//   }, [results]);

//   // Save answer to db after recording stops
//   useEffect(() => {
//     if (!isRecording && userAnswer.length > 10) {
//       updateUserAnswerInDB();
//     }
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [isRecording]);

//   // Handle starting or stopping recording
//   const startStopRecording = useCallback(() => {
//     if (isRecording) {
//       stopSpeechToText();
//     } else {
//       // restart with the currently selected language
//       setUserAnswer("");
//       setResults([]);
//       startSpeechToText({ lang: selectedLanguage });
//     }
//   }, [isRecording, stopSpeechToText, startSpeechToText, selectedLanguage]);

//   // Update answer in the database
//   const updateUserAnswerInDB = async () => {
//     setLoading(true);
//     try {
//       console.log("User Answer to save.", userAnswer);
//       if (mockInterviewQues[activeQuest]?.question && userAnswer) {
//         const response = await fetch("/api/gemini/feedback", {
//           method: "POST",
//           headers: { "Content-Type": "application/json" },
//           body: JSON.stringify({
//             question: mockInterviewQues[activeQuest]?.question,
//             userAnswer,
//             selectedLanguage,
//           }),
//         });
//         const mockJsonResp = await response.json();

//         let parsed = mockJsonResp.feedback
//           .replace("```json", "")
//           .replace("```", "");
//         parsed = JSON.parse(parsed);
//         console.log("Parsed Gemini response.", parsed);

//         await db.insert(UserAnswer).values({
//           userAns: userAnswer,
//           feedback: parsed.feedback,
//           question: mockInterviewQues[activeQuest]?.question,
//           rating: parsed.rating,
//           mockIdRef: interviewData?.mockId,
//           correctAnswer: mockInterviewQues[activeQuest]?.answer,
//           userEmail: user?.primaryEmailAddress.emailAddress,
//           createdAt: moment().format("DD-MM-yyyy"),
//         });

//         toast("User Answer recorded successfully!");
//       }
//       setUserAnswer("");
//       setResults([]);
//     } catch (error) {
//       console.error(error);
//       toast.error("Failed to save answer.");
//     } finally {
//       setLoading(false);
//     }
//   };

//   return (
//     <div className="flex justify-center items-center flex-col">
//       {/* Language picker */}
//       <select
//         value={selectedLanguage}
//         onChange={(e) => setSelectedLanguage(e.target.value)}
//         disabled={isRecording}
//         className="mb-5 p-2 border rounded-md"
//       >
//         {supportedLanguages.map((item) => (
//           <option key={item.code} value={item.code}>
//             {item.label}
//           </option>
//         ))}
//       </select>

//       {/* Webcam Section */}
//       <div className="h-full flex flex-col items-center justify-center bg-gray-200 rounded-lg p-5 mt-20 mb-10">
//         <Image
//           alt="webcam"
//           src="/webcam.png"
//           width={200}
//           height={200}
//           className="absolute"
//         />
//         <Webcam mirrored={true} style={{ height: 300, width: "100%" }} />
//       </div>

//       {/* Recording Button */}
//       <Button
//         disabled={loading}
//         className="cursor-pointer"
//         onClick={startStopRecording}
//         variant="outline"
//       >
//         {isRecording ? (
//           <h2 className="text-red-600 flex gap-2 items-center">
//             <StopCircle /> Stop Recording
//           </h2>
//         ) : (
//           <h2 className="flex gap-2 items-center">
//             <Mic /> Record Answer
//           </h2>
//         )}
//       </Button>

//       {/* Display recorded answer for preview or debug (optional) */}
//       <p className="mt-3">
//         <strong>Transcribed Answer:</strong> {userAnswer}
//       </p>
//     </div>
//   );
// }

// export default RecordAnswer;
"use client";

import React, { useEffect, useState, useCallback } from "react";
import Webcam from "react-webcam";
import Image from "next/image";
import { Button } from "../../../../../../components/ui/button";
import useSpeechToText from "react-hook-speech-to-text";
import { Mic, StopCircle } from "lucide-react";
import { toast } from "sonner";
import { db } from "../../../../../../utils/db";
import { UserAnswer } from "../../../../../../utils/schema";
import { useUser } from "@clerk/nextjs";
import moment from "moment";
import { ReactMediaRecorder } from "react-media-recorder";

function RecordAnswer({ mockInterviewQues, activeQuest, interviewData }) {
  const [userAnswer, setUserAnswer] = useState("");
  const [loading, setLoading] = useState(false);
  const [selectedLanguage, setSelectedLanguage] = useState("en-US");
  const { user } = useUser();

  const deepgramLangMap = {
    "zh-CN": "zh",
    "zh-TW": "zh-TW",
    "fr-FR": "fr",
    "es-ES": "es",
    "ar-SA": "ar",
    "de-DE": "de",
    "ja-JP": "ja",
    "it-IT": "it",
    "pt-PT": "pt",
    "pt-BR": "pt",
    "ru-RU": "ru",
    "ko-KR": "ko",
    "tr-TR": "tr",
  };

  const supportedLanguages = [
    { code: "en-US", label: "English (US)" },
    { code: "en-GB", label: "English (UK)" },
    { code: "ur-PK", label: "Urdu (PK)" },
    { code: "hi-IN", label: "Hindi (IN)" },
    { code: "fr-FR", label: "French (FR)" },
    { code: "zh-CN", label: "Chinese (Simplified)" },
    { code: "zh-TW", label: "Chinese (Traditional)" },
    { code: "es-ES", label: "Spanish (ES)" },
    { code: "ar-SA", label: "Arabic (SA)" },
    { code: "de-DE", label: "German (DE)" },
    { code: "ja-JP", label: "Japanese (JP)" },
    { code: "it-IT", label: "Italian (IT)" },
    { code: "pt-PT", label: "Portuguese (PT)" },
    { code: "pt-BR", label: "Portuguese (BR)" },
    { code: "ru-RU", label: "Russian (RU)" },
    { code: "ko-KR", label: "Korean (KR)" },
    { code: "tr-TR", label: "Turkish (TR)" },
  ];

  const webSpeechSupportedLanguages = ["en-US", "en-GB", "ur-PK", "hi-IN"];
  const isWebSpeechLanguage =
    webSpeechSupportedLanguages.includes(selectedLanguage);

  const {
    results,
    isRecording,
    startSpeechToText,
    stopSpeechToText,
    setResults,
  } = useSpeechToText({
    continuous: true,
    useLegacyResults: false,
    speechRecognitionLang: selectedLanguage,
  });

  useEffect(() => {
    if (results.length > 0) {
      setUserAnswer(
        (prev) => prev + results[results.length - 1].transcript + " "
      );
    }
  }, [results]);

  useEffect(() => {
    if (!isRecording && userAnswer.length > 10) {
      updateUserAnswerInDB(userAnswer);
    }
  }, [isRecording]);

  const startStopRecording = useCallback(() => {
    if (isRecording) {
      stopSpeechToText();
    } else {
      setUserAnswer("");
      setResults([]);
      startSpeechToText({ lang: selectedLanguage });
    }
  }, [isRecording, stopSpeechToText, startSpeechToText, selectedLanguage]);

  const updateUserAnswerInDB = async (transcript) => {
    setLoading(true);
    try {
      const response = await fetch("/api/gemini/feedback", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          question: mockInterviewQues[activeQuest]?.question,
          userAnswer: transcript,
          selectedLanguage,
        }),
      });

      const mockJsonResp = await response.json();
      let parsed = mockJsonResp.feedback
        .replace("```json", "")
        .replace("```", "");
      parsed = JSON.parse(parsed);

      await db.insert(UserAnswer).values({
        userAns: transcript,
        feedback: parsed.feedback,
        question: mockInterviewQues[activeQuest]?.question,
        rating: parsed.rating,
        mockIdRef: interviewData?.mockId,
        correctAnswer: mockInterviewQues[activeQuest]?.answer,
        userEmail: user?.primaryEmailAddress.emailAddress,
        createdAt: moment().format("DD-MM-yyyy"),
      });

      toast("Answer recorded and saved!");
    } catch (error) {
      console.error(error);
      toast.error("Failed to save answer.");
    } finally {
      setLoading(false);
      setUserAnswer("");
      setResults([]);
    }
  };

  return (
    <div className="flex justify-center items-center flex-col">
      <select
        value={selectedLanguage}
        onChange={(e) => setSelectedLanguage(e.target.value)}
        disabled={isRecording || loading}
        className="mb-5 p-2 border rounded-md"
      >
        {supportedLanguages.map((item) => (
          <option key={item.code} value={item.code}>
            {item.label}
          </option>
        ))}
      </select>

      <div className="h-full flex flex-col items-center justify-center bg-gray-200 rounded-lg p-5 mt-10 mb-5">
        <Image
          alt="webcam"
          src="/webcam.png"
          width={200}
          height={200}
          className="absolute"
        />
        <Webcam mirrored={true} style={{ height: 300, width: "100%" }} />
      </div>

      {isWebSpeechLanguage ? (
        <>
          <Button
            disabled={loading}
            className="cursor-pointer"
            onClick={startStopRecording}
            variant="outline"
          >
            {isRecording ? (
              <span className="text-red-600 flex gap-2 items-center">
                <StopCircle /> Stop Recording
              </span>
            ) : (
              <span className="flex gap-2 items-center">
                <Mic /> Record Answer
              </span>
            )}
          </Button>

          <p className="mt-3">
            <strong>Transcribed Answer:</strong> {userAnswer}
          </p>
        </>
      ) : (
        <ReactMediaRecorder
          audio
          render={({ status, startRecording, stopRecording, mediaBlobUrl }) => (
            <div className="flex flex-col items-center">
              <Button
                disabled={loading}
                className="cursor-pointer"
                onClick={
                  status === "recording" ? stopRecording : startRecording
                }
                variant="outline"
              >
                {status === "recording" ? (
                  <span className="text-red-600 flex gap-2 items-center">
                    <StopCircle /> Stop Recording
                  </span>
                ) : (
                  <span className="flex gap-2 items-center">
                    <Mic /> Record Answer
                  </span>
                )}
              </Button>

              {mediaBlobUrl && (
                <audio controls className="mt-4" src={mediaBlobUrl} />
              )}
            </div>
          )}
          onStop={async (blobUrl, blob) => {
            setLoading(true);
            try {
              const formData = new FormData();
             formData.append("file", blob, "recording.webm");

              formData.append(
                "language",
                deepgramLangMap[selectedLanguage] || selectedLanguage
              );
              formData.append(
                "question",
                mockInterviewQues[activeQuest]?.question
              );

              const res = await fetch("/api/deepgram", {
                method: "POST",
                body: formData,
              });

              const data = await res.json();
              if (!res.ok)
                throw new Error(data.message || "Transcription failed");

              await updateUserAnswerInDB(data.transcript);
              setUserAnswer(data.transcript);
            } catch (err) {
              toast.error("Deepgram Error: " + err.message);
            } finally {
              setLoading(false);
            }
          }}
        />
      )}
    </div>
  );
}

export default RecordAnswer;
